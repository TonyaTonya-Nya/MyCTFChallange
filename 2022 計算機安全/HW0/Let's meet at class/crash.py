from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes
import random
import math
import os


p = 92017932396773207330365205210913184771249549355771692523246399384571269833668487945963934319507538171501041280674304304879328757539798699280378034748542218248740777575679398093116579809607067129824965250071416089841516538588253944223235904445546895574651603636188746948921937704060334290364304972412697492577
enc = 87051682992840829567429886737255563980229964191963649650455667117285375334750716083826527488071966389632402954644144719710970265754062176648776448421065665281172133368294041777397049228273163978348132440822019295870429065335674151133125629968366491582233750452365390672536361224322642295053741696809519283644
hint = 112112804524582393858675176460595338484428048338611753655869733059768929120327158352572131172253127933611583356499525126040647290513660017529498493355846656594143774393256151536590212031416153303085867445488047592792290033548349001067687775149867134619114482370143917491889371548968347491490942978508386339813
hint = hint ^ pow(4668, 65537, p)

# keys[0]=pow(591, 65537, p)
# keys[1]=pow(1516, 65537, p)
# keys[2]=pow(2849, 65537, p)
# keys[3]=pow(3451, 65537, p)
# keys[4]=pow(4668, 65537, p)


candicate01 = []
candicate23 = []
candicate01.sort()
candicate23.sort()

for i in range(2, 1001):
    for j in range(1002, 2001):
        candicate01.append(pow(i, 65537, p) ^ pow(j, 65537, p) ^ hint)


for i in range(2002, 3001):
    for j in range(3002, 4001):
        candicate23.append(pow(i, 65537, p) ^ pow(j, 65537, p))


def binary_search(data, key):
    low = 0
    upper = len(data) - 1
    while low <= upper:
        mid = int((low + upper) / 2)
        if data[mid] < key:
            low = mid + 1
        elif data[mid] > key:
            upper = mid - 1
        else:
            return mid
    return -1


# 求 middle
middle = 0
for k in candicate01:
    index = binary_search(candicate23, k)
    if index >= 0:
        middle = k
        break

middle = 65000824822479090990250249803092978698952537797227596297460832220769296518926796721132924980811816299560767106766000138926216111053348234353465962958413960105856281338463024989569326365982288329674184623403166667107822681105245959552677180495035513319177711721412402410328452135071911854607398594414246443202


# 求 keys
keys = []
for i in range(2, 1001):
    for j in range(1002, 2001):
        if (middle == pow(i, 65537, p) ^ pow(j, 65537, p) ^ hint):
            keys.append(pow(i, 65537, p))
            keys.append(pow(j, 65537, p))


for i in range(2002, 3001):
    for j in range(3002, 4001):
        if (middle == pow(i, 65537, p) ^ pow(j, 65537, p)):
            keys.append(pow(i, 65537, p))
            keys.append(pow(j, 65537, p))

keys.append(pow(4668, 65537, p))

# 拆 flag
enc = enc * pow(keys[0]*keys[1]*keys[2]*keys[3]*keys[4], -1, p) % p
print(long_to_bytes(enc))
